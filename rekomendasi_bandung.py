# -*- coding: utf-8 -*-
"""Rekomendasi_Bandung.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xXuYATxPaxf43vWMcxdoxIqWKcdVcMpa
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/Reccomendation_System_Dicoding

"""# Instalasi dan Import Library"""

!pip install Sastrawi

"""**Insight :** Menginstal library Sastrawi untuk kebutuhan preprocessing teks bahasa Indonesia (stopword removal dan stemming).

"""

# Import library yang diperlukan
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

from sklearn.feature_extraction.text import TfidfVectorizer
from Sastrawi.Stemmer.StemmerFactory import StemmerFactory
from Sastrawi.StopWordRemover.StopWordRemoverFactory import StopWordRemoverFactory
from sklearn.metrics.pairwise import cosine_similarity

from zipfile import ZipFile
from pathlib import Path

import tensorflow as tf # Make sure tensorflow is imported as tf
from tensorflow import keras
from tensorflow.keras import layers

"""**Insight :** Library di atas meliputi:

- Visualisasi (matplotlib, seaborn, plotly

- Preprocessing Teks (Sastrawi, TfidfVectorizer)

- Rekomendasi berbasis konten (cosine_similarity)

- Model rekomendasi neural network (TensorFlow)



"""

# Inisialisasi TF-IDF, Stemmer, dan Stopword Remover
tfidf_vectorizer_model = TfidfVectorizer(max_features=5000) # Renamed the variable
stem = StemmerFactory().create_stemmer()
stopword = StopWordRemoverFactory().create_stop_word_remover()

"""**Insight :**
- TF-IDF digunakan untuk mengubah teks (kategori wisata) menjadi fitur numerik.

- Stemmer dan stopword remover untuk preprocessing teks (jika digunakan).

## Load Dataset
"""

df_rating = pd.read_csv('/content/drive/MyDrive/Reccomendation_System_Dicoding/tourism_rating.csv')
df_place = pd.read_csv('/content/drive/MyDrive/Reccomendation_System_Dicoding/tourism_with_id.csv')
df_user = pd.read_csv('/content/drive/MyDrive/Reccomendation_System_Dicoding/user.csv')

"""**Insight :** Tiga sumber dataset

- df_rating: Data rating dari user

- df_place: Data tempat wisata

- df_user: Data pengguna

# Eksplorasi Awal Dataset
"""

# Cek informasi dasar tiap dataset
df_rating.info()

df_place.info()

df_user.info()

# Tampilkan beberapa data teratas
df_place.head()

df_user.head()

df_rating.head()

"""# Pembersihan dan Filter Data"""

# Drop kolom yang tidak relevan
df_place = df_place.drop(['Time_Minutes','Unnamed: 11','Unnamed: 12'], axis=1)

# Filter hanya tempat wisata di Kota Bandung
df_place = df_place[df_place['City'] == 'Bandung']

df_place.head(1)

# Filter data rating hanya untuk tempat wisata di Bandung
df_rating = pd.merge(df_rating, df_place[['Place_Id']], how='right', on='Place_Id')

df_rating.head(1)

# Filter user yang pernah memberi rating di Bandung
df_user = pd.merge(df_user, df_rating[['User_Id']], how='right', on='User_Id').drop_duplicates().sort_values('User_Id')

df_user.head(1)

"""# Visualisasi Data

## Tempat Wisata dengan Rating Terbanyak
"""

# Buat dataframe tempat wisata dengan rating terbanyak
top_10 = df_rating['Place_Id'].value_counts().reset_index(name='rating_count').rename(columns={'index': 'Place_Id'})[0:10]

# Gabungkan dengan nama tempat
top_10 = pd.merge(top_10, df_place[['Place_Id','Place_Name']], how='left', on='Place_Id')

# Visualisasi
plt.figure(figsize=(10,6))
sns.barplot(x='rating_count', y='Place_Name', data=top_10)
plt.title('10 Tempat Wisata di Bandung dengan Rating Terbanyak', pad=20)
plt.xlabel('Jumlah Rating')
plt.ylabel('Nama Tempat')
plt.tight_layout()
plt.show()

"""**Insight:**
Menampilkan 10 tempat wisata paling populer berdasarkan jumlah rating dari user.

## Perbandingan Kategori Tempat Wisata
"""

sns.countplot(y='Category', data=df_place)
plt.title('Perbandingan Jumlah Kategori Wisata di Kota Bandung', pad=20)
plt.show()

"""**Insight :** Menunjukkan persebaran jenis kategori wisata (kuliner, alam, hiburan, dll).

##  Distribusi Usia Pengguna
"""

plt.figure(figsize=(5,3))
sns.boxplot(df_user['Age'])
plt.title('Distribusi Usia User', pad=20)
plt.show()

"""**Insight:** Analisis demografi user: usia & asal kota.

## Asal Kota User
"""

asal_kota = df_user['Location'].apply(lambda x: x.split(',')[0])

plt.figure(figsize=(8,6))
sns.countplot(y=asal_kota)
plt.title('Jumlah Asal Kota dari User')
plt.show()

"""**Insght:** Berguna untuk personalisasi rekomendasi berdasarkan asal atau usia.

## Informasi Umum Tempat Wisata
"""

print(f"Terdapat {df_place['Place_Name'].nunique()} Tempat Wisata di Kota Bandung")
print(f"Terdiri dari {df_place['Category'].nunique()} Kategori Wisata yaitu")
print('Kategori Wisata  :', df_place['Category'].unique())

"""## Pie Chart Kategori Tempat Wisata"""

columns_category_type = df_place['Category'].unique().tolist()
plt.rcParams["figure.figsize"] = (15,8)
plt.pie(df_place['Category'].value_counts(), autopct='%1.1f%%',
        wedgeprops={'edgecolor': 'black'}, counterclock=False, shadow=True, startangle=25,
        radius=1.3, labels=columns_category_type, textprops={'fontsize': 15, 'weight': 'bold'})
plt.tight_layout()
plt.show()

for label, count in df_place['Category'].value_counts().items():
    print("Jumlah Tempat Wisata dengan Kategori", label, ":", count)

"""## Jumlah User Berdasarkan Kota"""

for label, count in df_user['Location'].value_counts().items():
    print("Jumlah User dari Kota", label, ":", count)

"""## Model Content Based Filtering"""

# Model Content Based Filtering
tfidf_vectorizer_for_category = TfidfVectorizer() # Renamed the variable again for clarity in this section
tfidf_vectorizer_for_category.fit(df_place['Category'])
tfidf_vectorizer_for_category.get_feature_names_out()

"""**Insight** : Membuat sistem rekomendasi berbasis konten dengan kemiripan kategori wisata."""

tfidf_matrix = tfidf_vectorizer_for_category.fit_transform(df_place['Category'])
tfidf_matrix.shape

tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tfidf_vectorizer_for_category.get_feature_names_out(),
    index=df_place.Place_Name
).sample(10, axis=0)

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

cosine_sim_df = pd.DataFrame(
    cosine_sim, index=df_place.Place_Name, columns=df_place.Place_Name)
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(10, axis=0)

def destination_recommendations(place_name, similarity_data=cosine_sim_df, items=df_place[['Place_Name', 'Category']], k=10):
    index = similarity_data.loc[:,place_name].to_numpy().argpartition(range(-1, -k, -1))
    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    closest = closest.drop(place_name, errors='ignore')
    return pd.DataFrame(closest).merge(items).head(k)

"""**Insight :**  Menyediakan rekomendasi wisata berdasarkan tempat yang mirip (dari sisi kategori)."""

place_name = 'Trans Studio Bandung'
df_place[df_place.Place_Name.eq(place_name)]

destination_recommendations(place_name=place_name)

"""### Model Collaborative

#### 1. Membuat Salinan Data rating
"""

# Membaca dataset untuk dilakukan encoding
df = df_rating.copy()
df.head()

"""#### 2. Melakukan Encoding"""

def dict_encoder(col, data=df):

  # Mengubah kolom suatu dataframe menjadi list tanpa nilai yang sama
  unique_val = data[col].unique().tolist()

  # Melakukan encoding value kolom suatu dataframe ke angka
  val_to_val_encoded = {x: i for i, x in enumerate(unique_val)}

  # Melakukan proses encoding angka ke value dari kolom suatu dataframe
  val_encoded_to_val = {i: x for i, x in enumerate(unique_val)}
  return val_to_val_encoded, val_encoded_to_val

# Encoding User_Id
user_to_user_encoded, user_encoded_to_user = dict_encoder('User_Id')

# Mapping User_Id ke dataframe
df['user'] = df['User_Id'].map(user_to_user_encoded)

# Encoding Place_Id
place_to_place_encoded, place_encoded_to_place = dict_encoder('Place_Id')

# Mapping Place_Id ke dataframe place
df['place'] = df['Place_Id'].map(place_to_place_encoded)

"""**Insight :**
- Encode User dan Tempat ke dalam bentuk integer (untuk model embedding).

- Skala rating dari 0â€“1.
"""

# Mendapatkan jumlah user dan place
num_users, num_place = len(user_to_user_encoded), len(place_to_place_encoded)

# Mengubah rating menjadi nilai float
df['Place_Ratings'] = df['Place_Ratings'].values.astype(np.float32)

# Mendapatkan nilai minimum dan maksimum rating
min_rating, max_rating = min(df['Place_Ratings']), max(df['Place_Ratings'])

print(f'Number of User: {num_users}, Number of Place: {num_place}, Min Rating: {min_rating}, Max Rating: {max_rating}')

# Mengacak dataset
df = df.sample(frac=1, random_state=42)
df.head(2)

"""## Pemodelan Machine Learning dengan RecommenderNet"""

# Membuat variabel x untuk mencocokkan data user dan place menjadi satu value
x = df[['user', 'place']].values

# Membuat variabel y untuk membuat rating dari hasil
y = df['Place_Ratings'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

# Membagi menjadi 80% data train dan 20% data validasi
train_indices = int(0.8 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

class RecommenderNet(tf.keras.Model): # Use tf.keras.Model here

  def __init__(self, num_users, num_places, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_places = num_places
    self.embedding_size = embedding_size

    self.user_embedding = layers.Embedding(
        num_users,
        embedding_size,
        embeddings_initializer='he_normal',
        embeddings_regularizer=keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1)

    self.places_embedding = layers.Embedding(
        num_places,
        embedding_size,
        embeddings_initializer='he_normal',
        embeddings_regularizer=keras.regularizers.l2(1e-6)
    )
    self.places_bias = layers.Embedding(num_places, 1)

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:, 0])
    user_bias = self.user_bias(inputs[:, 0])
    places_vector = self.places_embedding(inputs[:, 1])
    places_bias = self.places_bias(inputs[:, 1])

    dot_user_places = tf.tensordot(user_vector, places_vector, 2)
    x = dot_user_places + user_bias + places_bias

    return tf.nn.sigmoid(x)

"""**Insight:**
Model ini menggunakan:

- Embedding Layer untuk User dan Place

- Bias untuk masing-masing entitas

- Dot product + sigmoid = rating prediksi
"""

model = RecommenderNet(num_users, num_place, 50) # inisialisasi model

# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.0004),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""**Insight**
- Menggunakan callback untuk menghentikan pelatihan lebih awal jika error validasi cukup kecil.

- Melatih dengan RootMeanSquaredError untuk akurasi prediksi rating.
"""

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('val_root_mean_squared_error')<0.25):
      print('Lapor! Metriks validasi sudah sesuai harapan')
      self.model.stop_training = True

# Memulai training
history = model.fit(
    x = x_train,
    y = y_train,
    epochs = 100,
    validation_data = (x_val, y_val),
    callbacks = [myCallback()]
)

# Menampilkan plot loss dan validation
plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.ylim(ymin=0, ymax=0.4)
plt.legend(['train', 'test'], loc='center left')
plt.show()

"""**Insight:**
Melihat apakah model overfitting atau underfitting dari plot metrik.

# Prediksi Top 10 Rekomendasi Pariwisata di Bandung
"""

# Menyiapkan dataframe
place_df = df_place[['Place_Id','Place_Name','Category','Rating','Price']]
place_df.columns = ['id','place_name','category','rating','price']
df = df_rating.copy()

# Mengambil sample user
user_id = df.User_Id.sample(1).iloc[0]
place_visited_by_user = df[df.User_Id == user_id]

# Membuat data lokasi yang belum dikunjungi user
place_not_visited = place_df[~place_df['id'].isin(place_visited_by_user.Place_Id.values)]['id']
place_not_visited = list(
    set(place_not_visited)
    .intersection(set(place_to_place_encoded.keys()))
)

place_not_visited = [[place_to_place_encoded.get(x)] for x in place_not_visited]
user_encoder = user_to_user_encoded.get(user_id)
user_place_array = np.hstack(
    ([[user_encoder]] * len(place_not_visited), place_not_visited)
)

# Prediksi rating untuk semua tempat yang belum dikunjungi user
ratings = model.predict(user_place_array).flatten()

# Ambil indeks 10 tempat dengan rating prediksi tertinggi
top_ratings_indices = ratings.argsort()[-10:][::-1]

# Ambil ID tempat dari hasil prediksi terbaik
recommended_place_ids = [
    place_encoded_to_place.get(place_not_visited[idx][0])
    for idx in top_ratings_indices
]

# Header rekomendasi
print(f"Daftar rekomendasi untuk: User {user_id}")
print("=" * 45, '\n')

# Menampilkan 5 tempat dengan rating tertinggi yang pernah dikunjungi user
print("Tempat dengan rating wisata paling tinggi dari user")
print("-" * 60)

top_place_user_ids = (
    place_visited_by_user
    .sort_values(by='Place_Ratings', ascending=False)
    .head(5)
    .Place_Id
    .values
)

top_place_user_df = place_df[place_df['id'].isin(top_place_user_ids)]

for row in top_place_user_df.itertuples():
    print(f"{row.place_name} : {row.category}")

print("\n" + "-" * 60)
print("Top 10 Rekomendasi Tempat Wisata untuk Anda")
print("-" * 60)

# Menampilkan daftar 10 tempat rekomendasi
recommended_places_df = place_df[place_df['id'].isin(recommended_place_ids)]

for i, row in enumerate(recommended_places_df.itertuples(), start=1):
    print(f"{i}. {row.place_name}")
    print(f"    Kategori       : {row.category}")
    print(f"    Harga Tiket    : {row.price}")
    print(f"    Rating Wisata  : {row.rating}\n")

print("=" * 45)

"""**Insight Akhir :**
- Jumlah tempat wisata di Bandung sangat bervariasi dalam kategori, dan bisa direkomendasikan baik berdasarkan konten (kategori) maupun rating user.

- Sistem ini dapat dikembangkan lebih lanjut menjadi aplikasi mobile atau web, dengan input dari lokasi dan minat user.


"""

